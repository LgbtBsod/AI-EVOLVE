Ты lead Game Developer c 50ти летним стажем. Ты учувствовал в разработке множества культовых проектов.
Проведи код ревью проекта. Проверь архитектуру . Исправь проблемы архитектуры, логические ошибки. Ошибки реализации. Произведи рефакторинг проекта под модульную архитектуру по принципу единой ответственности. Не потеряй игровые механики. убедить что весь функционал используется и правильно интегрирован. При произведении рефакторинга, если модуль уже создан производи корректировки в нем, чтобы избежать создания новой версии модулей, которые могут потерять функциональность и связь с исходным проектом. при создании новых модулей следи за тем, что новые модули интегрированы в общую логику.


### Полный проект видеоигры: "Эволюционная Адаптация: Генетический Резонанс" (Интегрированная Версия)

---

#### 1. Основная концепция и цели
Описание: Игрок выступает в роли "Направляющего Эволюции", косвенно управляя протагонистом через систему спецэффектов. Цель - поиск Маяка через взаимодействие с NPC, исследование мира и следование эхо-следам. 

Ключевые механики:
- Прогрессия через опыт памяти (персональная и общая для врагов)
- Многофазовые боссы и мутанты с уникальными скиллами
- Система генов, эмоций и мутаций
- Обучение ИИ использованию скиллов
- Изометрическая проекция с возможностью управления камерой

---

#### 2. Технические требования
- Язык программирования: Python 3.9+
- Фреймворк: Panda3D (для изометрической проекции, 3D-графики и производительности)
- Обучение ИИ: Stable Baselines3
- UI: DirectGUI (встроенный в Panda3D)

---

#### 3. Структура проекта
copy


evolution_adaptation/
├── main.py                  # Точка входа (ShowBase)
├── config.py                # Конфигурация игры
├── game_engine/             
│   ├── __init__.py
│   ├── game_core.py         # Основной игровой цикл
│   ├── camera.py            # Система камеры
│   └── world.py             # Управление игровым миром
├── entities/                
│   ├── __init__.py
│   ├── player.py            # Класс игрока
│   ├── npc.py               
│   ├── items.py             # Базовый класс Item и предметы
│   ├── enemies.py           
│   ├── bosses.py            # Боссы
│   └── mutants.py           # Химеры/мутанты
├── systems/                 
│   ├── __init__.py
│   ├── genetics.py          
│   ├── emotions.py          
│   ├── effects.py           # Система эффектов
│   ├── skills.py            # Система скиллов
│   ├── damage.py            # Система урона
│   ├── inventory.py         # Инвентарь и слабости
│   ├── progression.py       
│   ├── ai_controller.py     # ИИ управления персонажами
│   └── memory_system.py     # Система памяти
├── ui/                      
│   ├── __init__.py
│   ├── menus.py             
│   ├── hud.py               
│   ├── minimap.py           
│   └── buttons.py           
├── ai/                      
│   ├── __init__.py
│   ├── behavior_tree.py     
│   └── learning.py          # Обучение ИИ использованию скиллов
└── saves/                   
    ├── __init__.py
    └── save_manager.py      

---

#### 4. Игровые системы

##### 4.1. Базовый класс Item (entities/items.py)
Описание: Базовый класс для всех предметов в игре.

Пример реализации:
```python
from panda3d.core import *
from direct.actor.Actor import Actor

class Item:
    def __init__(self, name, item_type, rarity="common", stack_size=1):
        self.name = name
        self.item_type = item_type  # weapon, armor, consumable, etc.
        self.rarity = rarity
        self.stack_size = stack_size
        self.quantity = 1
        self.effects = []  # Эффекты при использовании/экипировке
        self.requirements = {}  # Требования для использования
        self.visual_model = None  # 3D модель предмета
        
    def use(self, user):
        """Использовать предмет"""
        if self.check_requirements(user):
            for effect in self.effects:
                effect.apply(user, user)
            return True
        return False
        
    def check_requirements(self, user):
        """Проверить требования для использования"""
        for stat, value in self.requirements.items():
            if getattr(user, stat, 0) < value:
                return False
        return True
        
    def create_visual(self, position):
        """Создать визуальное представление предмета в мире"""
        if self.visual_model:
            item_node = self.visual_model.copyTo(render)
            item_node.setPos(*position)
            return item_node
        return None

class Weapon(Item):
    def __init__(self, name,
_(self, name, da
dam
def __init__(self, name, dam
layer),
            "source_level": getattr(source, 'level', 1)
        }
        modified_value = self.get_modified_value(context)
        
        # Применение эффекта
        if isinstance(modified_value, dict):
            for stat, modifier in modified_value.items():
                current = getattr(target, stat, 0)
                setattr(target, stat, current + modifier)
        else:
            target.apply_direct_effect(modified_value)
        
        # Воспроизведение визуальных эффектов
        if self.visuals:
            self.visuals.play(target.position)
        
        # Регистрация в статистике
        if hasattr(source, 'effect_statistics'):
            source.effect_statistics.record_trigger(self.name)
        
        return True
    
    def can_apply(self, source, target):
        """Проверка возможности применения эффекта"""
        # Проверка постоянных условий
        if self.is_permanent and self.permanent_condition:
            return self.permanent_condition(source, target, {})
        
        # Проверка конфликтов
        if hasattr(target, 'active_effects'):
            for active_effect in target.active_effects:
                if self.conflicts_with(active_effect):
                    if self.conflict_resolution == ConflictResolution.IGNORE:
                        return False
                    elif self.conflict_resolution == ConflictResolution.REPLACE:
                        target.remove_effect(active_effect)
        
        return True
    
    def conflicts_with(self, other):
        """Проверка конфликта с другим эффектом"""
        return any(tag in other.tags for tag in self.cancellation_tags)
    
    def get_modified_value(self, context):
        """Расчет модифицированного значения эффекта"""
        modified_value = self.value
        
        # Применение базовых модификаторов
        if isinstance(modified_value, (int, float)):
            modified_value *= self.balance.base_power * self.balance.scaling_factor
        else:
            # Для словарей применяем модификаторы к каждому значению
            modified_value = {
                k: v * self.balance.base_power * self.balance.scaling_factor
                for k, v in modified_value.items()
            }
        
        # Применение динамических параметров
        for param, func in self.dynamic_parameters.items():
            if param in modified_value if isinstance(modified_value, dict) else True:
                modified_value = func(context["source"], context["target"])
        
        # Применение контекстных модификаторов
        if context.get("is_pvp"):
            multiplier = self.balance.pvp_modifier
        else:
            multiplier = self.balance.pve_modifier
        
        if isinstance(modified_value, dict):
            modified_value = {k: v * multiplier for k, v in modified_value.items()}
        else:
            modified_value *= multiplier
        
        # Применение масштабирования с уровнем
        if "source_level" in context and self.balance.level_scaling > 0:
            level_factor = 1.0 + (context["source_level"] - 1) * self.balance.level_scaling
            if isinstance(modified_value, dict):
                modified_value = {k: v * level_factor for k, v in modified_value.items()}
            else:
                modified_value *= level_factor
        
        return modified_value

class SpecialEffect:
    def __init__(
        self,
        chance: float,
        effect: Effect,
        trigger_condition: str,
        cooldown: float = 0,
        max_procs: int = 0,
        conditions: List[Callable] = None,
        combination_effects: List['SpecialEffect'] = None,
        track_stats: bool = False,
        achievement_id: Optional[str] = None,
        delay: float = 0,
        delayed_effect: Optional['SpecialEffect'] = None,
        chain_effects: List['SpecialEffect'] = None,
        chain_delay: float = 0
    ):
        self.chance = chance
        self.effect = effect
        self.trigger_condition = trigger_condition
        self.cooldown = cooldown
self
elf.cooldown = cooldown
        self
.max_procs = max_procs
        self.conditions = conditions or []
        self.combination_effects = combination_effects or []
        self.track_stats = track_stats
        self.achievement_id = achievement_id
        self.delay = delay
        self.delayed_effect = delayed_effect
        self.chain_effects = chain_effects or []
        self.chain_delay = chain_delay
        self.last_proc_time = 0
        self.proc_count = 0
        
    def can_trigger(self, source, target, trigger_type, context=None):
        """Проверяет, может ли эффект сработать в текущих условиях"""
        if context is None:
            context = {}
            
        if self.trigger_condition != trigger_type:
            return False
            
        if random.random() > self.chance:
            return False
            
        current_time = time.time()
        if self.cooldown > 0 and (current_time - self.last_proc_time) < self.cooldown:
            return False
            
        if self.max_procs > 0 and self.proc_count >= self.max_procs:
            return False
            
        if not self.effect.can_apply(source, target):
            return False
            
        for condition in self.conditions:
            if not condition(source, target, context):
                return False
                
        return True
    
    def trigger(self, source, target, context=None):
        """Активирует эффект"""
        if context is None:
            context = {}
            
        # Обрабатываем задержку
        if self.delay > 0:
            self._schedule_delayed_effect(source, target, context)
            return
        
        # Применяем основной эффект
        self.effect.apply(target, source)
        
        # Применяем комбинационные эффекты
        for combo_effect in self.combination_effects:
            if combo_effect.can_trigger(source, target, self.trigger_condition, context):
                combo_effect.trigger(source, target, context)
        
        # Планируем цепные эффекты
        if self.chain_effects:
            self._schedule_chain_effects(source, target, context)
        
        # Обновляем данные о срабатывании
        self.last_proc_time = time.time()
        self.proc_count += 1
        
        # Записываем статистику
        if self.track_stats and hasattr(source, 'effect_statistics'):
            source.effect_statistics.record_trigger(self.effect.name)
    
    def _schedule_delayed_effect(self, source, target, context):
        """Планирует отложенный эффект"""
        if self.delayed_effect:
            # В реальной реализации здесь был бы таймер
            pass
    
    def _schedule_chain_effects(self, source, target, context):
        """Планирует цепные эффекты"""
        if self.chain_effects:
            # В реальной реализации здесь был бы таймер
            pass
```

```

##### 4.3. Система скиллов (systems/skills.py)
Описание: Система активных и пассивных способностей персонажей.

Пример реализации:
```python
class Skill:
    def __init__(self, name, effect, cooldown=5.0, mana_cost=0, level_requirement=0):
        self.name = name
        self.effect = effect
        self.cooldown = cooldown
        self.mana_cost = mana_cost
        self.level_requirement = level_requirement
        self.last_used = -cooldown  # Чтобы можно было использовать сразу
        self.unlocked = False
        
    def can_use(self, entity, current_time):
        """Проверка возможности использования навыка"""
        if not self.unlocked:
            return False
        if current_time - self.last_used < self.cooldown:
            return False
        if hasattr(entity, 'mana') and entity.mana < self.mana_cost:
            return False
        if hasattr(entity, 'level') and entity.level < self.level_requirement:
            return False
        return True
    
    def use(self, entity, target=None, current_time=0):
        """Использование навыка"""
        if not self.can_use(entity, current_time):
            return False
        
        # Расход маны
        if hasattr(entity, 'mana'):
entity.mana -= self.mana_cost
        
        # Применение эффекта
        if target:
            self.effect.apply(target, entity)
        else:
            self.effect.apply(entity, entity)
        
        self.last_used = current_time
        return True

class SkillSystem:
    def __init__(self):
        self.skills = {}
        self.active_slots = [None, None, None]  # 3 слота для активных навыков
        
    def learn_skill(self, entity, skill_name):
        """Изучение навыка"""
        if skill_name in self.skills:
            skill = self.skills[skill_name]
            if skill.level_requirement <= entity.level:
                skill.unlocked = True
                entity.add_skill(skill)
                return True
        return False
    
    def assign_to_slot(self, skill_name, slot_index):
        """Назначение навыка на слот"""
        if 0 <= slot_index < len(self.active_slots):
            if skill_name in self.skills:
                self.active_slots[slot_index] = self.skills[skill_name]
                return True
        return False
    
    def use_slot(self, entity, slot_index, target=None, current_time=0):
        """Использование навыка из слота"""
        if 0 <= slot_index < len(self.active_slots):
            skill = self.active_slots[slot_index]
            if skill:
                return skill.use(entity, target, current_time)
        return False

# Пример навыка
dash_effect = Effect(
    name="Рывок",
    category=EffectCategory.INSTANT,
    value={"position_offset": (5, 0)},
    visuals=EffectVisuals(
        particle_effect="dash_trail",
        sound_effect="whoosh",
        screen_shake=0.2
    ),
    tags=["movement", "skill"]
)

dash_skill = Skill(
    name="Рывок",
    effect=dash_effect,
    cooldown=10.0,
    mana_cost=10,
    level_requirement=2
)
```

```

##### 4.4. Система урона (systems/damage.py)
Описание: Система расчета и применения урона с различными типами и защитами.

Пример реализации:
```python
class DamageType:
    PHYSICAL = "physical"
    FIRE = "fire"
    COLD = "cold"
    LIGHTNING = "lightning"
    ACID = "acid"
    TRUE = "true"

class Damage:
    def __init__(self, amount, damage_type, source=None):
        self.amount = amount
        self.damage_type = damage_type
        self.source = source
    
    def calculate(self, target):
        """Расчет финального урона с учетом защит"""
        if self.damage_type == DamageType.TRUE:
            return self.amount
        
        # Базовый расчет
        final_damage = self.amount
        
        # Учет сопротивлений
        resistance = target.get_resistance(self.damage_type)
        final_damage *= (1 - resistance)
        
        # Учет брони для физического урона
        if self.damage_type == DamageType.PHYSICAL:
            armor = target.get_armor()
            final_damage *= (1 - armor * 0.01)  # 1 armor = 1% reduction
        
        return max(1, int(final_damage))

class DamageSystem:
    def __init__(self):
        self.combinations = []
        self.catalytic_effects = []
        
    def deal_damage(self, target, damage):
        """Нанесение урона"""
        final_damage = damage.calculate(target)
        target.take_damage(final_damage, damage.damage_type)
        
        # Применяем эффект урона
        damage_effect = Effect(
            name="Урон",
            category=EffectCategory.INSTANT,
            value={"damage": final_damage},
            visuals=EffectVisuals(
                particle_effect="damage",
                sound_effect="impact"
            ),
            tags=["damage"]
        )
        damage_effect.apply(target, damage.source)
        
        # Проверка каталитических эффектов
        for effect in self.catalytic_effects:
            if effect.check(target, damage):
                effect.apply(target, damage.source)
        
        return final_damage
    
    def register_combination(self, types, effect):
        """Регистрация комбинации типов урона"""
        self.combinations.append((types, effect))
    
    def
check_combinations(se
)
    
    def check_combinations(se
lf, target, damage_types):
        """Проверка комбинаций урона"""
        for types, effect in self.combinations:
            if all(damage_type in damage_types for damage_type in types):
                effect.apply(target)
                return True
        return False

# Пример комбинации урона
plasma_effect = Effect(
    name="Плазменный взрыв",
    category=EffectCategory.INSTANT,
    value={"damage": 30},
    visuals=EffectVisuals(
        particle_effect="plasma_explosion",
        sound_effect="energy_burst",
        screen_shake=1.0
    ),
    tags=["combination", "plasma"]
)

damage_system = DamageSystem()
damage_system.register_combination(
    [DamageType.FIRE, DamageType.LIGHTNING],
    plasma_effect
)
Python



##### **4.5. Система инвентаря (systems/inventory.py)**
**Описание**: Управление предметами и экипировкой персонажа.

**Пример реализации**:
```python
class Inventory:
    def __init__(self, max_slots=20):
        self.max_slots = max_slots
        self.items = [None] * max_slots
        self.equipped_items = {}
        self.weaknesses = {
            "damage_type": ["acid", "fire"],
            "emotion": ["fear", "confusion"],
            "genetic": ["instability"]
        }
        
    def add_item(self, item):
        """Добавление предмета в инвентарь"""
        for i, slot in enumerate(self.items):
            if slot is None:
                self.items[i] = item
                self.show_pickup_effect(item)
                return True
        return False
        
    def equip_item(self, item, slot):
        """Экипировка предмета"""
        if item.slot_type == slot:
            self.equipped_items[slot] = item
            item.apply_equip_effect()
            self.show_equip_effect(item)
            
    def use_consumable(self, item_name):
        """Использование расходника"""
        item = self.get_item(item_name)
        if item and item.is_consumable():
            item.apply_effect()
            self.remove_item(item)
            return True
        return False
            
    def get_weakness_multiplier(self, damage_type, emotion=None):
        """Получение множителя урона для слабости"""
        multiplier = 1.0
        if damage_type in self.weaknesses["damage_type"]:
            multiplier *= 1.5
        if emotion and emotion in self.weaknesses["emotion"]:
            multiplier *= 1.3
        return multiplier

##### 4.6. Система памяти (systems/memory_system.py)
Описание: Система накопления опыта памяти для персонажей и врагов.

Пример реализации:
```python
class MemorySystem:
    def __init__(self):
        self.player_memory = PlayerMemory()
        self.enemy_memory_bank = EnemyMemoryBank()
        
    def add_experience(self, entity, experience_type, amount):
        """Добавление опыта в систему памяти"""
        if isinstance(entity, Player):
            self.player_memory.add_experience(experience_type, amount, multiplier=1.0)
        else:
            # Определяем тип врага
            if entity.is_basic_enemy:
                multiplier = 0.05
            else:  # сильный враг
                multiplier = 0.01
            self.enemy_memory_bank.add_experience(experience_type, amount, multiplier)
            
    def get_memory_level(self, entity):
        """Получение уровня памяти для сущности"""
        if isinstance(entity, Player):
            return self.player_memory.get_level()
        else:
            return self.enemy_memory_bank.get_level()

class PlayerMemory:
    def __init__(self):
        self.experience = {
            "kills": 0,
            "deaths": 0,
            "exploration": 0,
            "interactions": 0
        }
        self.level = 1
        self.skills_learned = set()
        
    def add_experience(self, exp_type, amount, multiplier=1.0):
        self.experience[exp_type] += amount * multiplier
        self.check_level_up()
        
    def check_level_up(self):
        # Расчет уровня на основе опыта
        total_exp = sum(self.experience.values())
        new_level = 1 + total_exp // 100
        if new_level > self.l
evel:
            self.level = new_level
            self.unlock_new_skills()

class EnemyMemoryBank:
    def __init__(self):
        self.shared_experience = {
            "kills": 0,
            "deaths": 0,
            "player_encounters": 0
        }
        self.level = 1
        self.shared_skills = set()
        
    def add_experience(self, exp_type, amount, multiplier=0.05):
        self.shared_experience[exp_type] += amount * multiplier
        self.check_evolution()
        
    def check_evolution(self):
        # Эволюция врагов на основе общего опыта
        total_exp = sum(self.shared_experience.values())
        new_level = 1 + total_exp // 500
        if new_level > self.level:
            self.level = new_level
            self.unlock_shared_skills()
Python



##### **4.7. Боссы (entities/bosses.py)**
**Описание**: Многофазовые боссы с уникальными скиллами.

**Пример реализации**:
```python
from panda3d.core import *
from direct.actor.Actor import Actor

class Boss(Actor):
    def __init__(self, boss_type, position):
        # Загрузка модели (пока куб для прототипа)
        model = loader.loadModel("models/boss_cube")
        super().__init__(model)
        
        self.setPos(*position)
        self.boss_type = boss_type
        self.health = 1000
        self.max_health = 1000
        self.phase = 1
        self.max_phases = 3
        self.abilities = self.load_abilities()
        self.weaknesses = self.load_weaknesses()
        self.memory_system = base.memory_system
        
        # Визуальные индикаторы
        self.phase_indicator = self.create_phase_indicator()
        
    def load_abilities(self):
        abilities = []
        if self.boss_type == "alpha_mutant":
            abilities.extend([
                GeneticVortex(phase=1),
                MutationWave(phase=1),
                PlasmaBurst(phase=2),
                InstabilityField(phase=3)
            ])
        elif self.boss_type == "chimera":
            abilities.extend([
                FireBreath(phase=1),
                TailWhip(phase=1),
                AcidSpit(phase=2),
                BerserkRage(phase=3)
            ])
        return abilities
        
    def update_phase(self):
        """Обновление фазы босса на основе здоровья"""
        new_phase = min(self.max_phases, self.max_phases - int(self.health / (self.max_health / self.max_phases)))
        if new_phase > self.phase:
            self.phase = new_phase
            self.unlock_phase_ability()
            self.update_weaknesses()
            self.phase_indicator.setColor(*self.get_phase_color())
            
    def unlock_phase_ability(self):
        """Разблокировка новой способности при смене фазы"""
        phase_abilities = [a for a in self.abilities if a.phase == self.phase]
        for ability in phase_abilities:
            ability.unlock()
            self.show_ability_unlock_effect(ability)
            
    def update_weaknesses(self):
        """Обновление слабостей для новой фазы"""
        if self.phase == 2:
            self.weaknesses.update({"damage_type": "cold"})
        elif self.phase == 3:
            self.weaknesses.update({"emotion": "fear"})
            
    def get_phase_color(self):
        colors = {
            1: (1, 0, 0, 1),    # Красный
            2: (1, 0.5, 0, 1),  # Оранжевый
            3: (0.5, 0, 1, 1)   # Фиолетовый
        }
        return colors.get(self.phase, (1, 1, 1, 1))
        
    def show_ability_unlock_effect(self, ability):
        """Визуальный эффект разблокировки способности"""
        effect = ParticleEffect()
        effect.loadConfig("effects/ability_unlock.ptf")
        effect.start(self)
        
        # Звуковой эффект
        sound = loader.loadSfx("sounds/ability_unlock.wav")
        sound.play()

##### 4.8. Химеры/Мутанты (entities/mutants.py)
Описание: Процедурно генерируемые мутанты с адаптивным поведением.

Пример реализации:
```python
class Mutant(Actor):
    def __init__(self, mutation_level, position):
        model = loader.loadModel("models/mutant_sphere")
sup
er().__init__(model)
        
        self.setPos(*position)
        self.mutation_level = mutation_level
        self.phase = 1
        self.max_phases = 2
        self.mutations = self.generate_mutations()
        self.abilities = self.derive_abilities()
        self.visual_mutations = self.create_visual_mutations()
        self.memory_system = base.memory_system
        
        # Получаем уровень из общей памяти
        self.memory_level = self.memory_system.get_memory_level(self)
        
    def generate_mutations(self):
        mutations = []
        for _ in range(self.mutation_level):
            mutation_type = random.choice(MUTATION_TYPES)
            mutation = MutationFactory.create(mutation_type)
            mutations.append(mutation)
        return mutations
        
    def derive_abilities(self):
        abilities = []
        for mutation in self.mutations:
            if mutation.ability:
                abilities.append(mutation.ability)
                
        # Добавляем способности на основе уровня памяти
        if self.memory_level >= 3:
            abilities.append(MemoryBlast())
        if self.memory_level >= 5:
            abilities.append(EvolutionaryLeap())
            
        return abilities
        
    def update_phase(self):
        """Обновление фазы мутанта"""
        if self.health < self.max_health * 0.5 and self.phase == 1:
            self.phase = 2
            self.unlock_phase_ability()
            self.show_mutation_evolution_effect()
            
    def unlock_phase_ability(self):
        """Разблокировка способности фазы"""
        phase_ability = self.get_phase_ability()
        if phase_ability:
            phase_ability.unlock()
            self.show_ability_unlock_effect(phase_ability)
            
    def show_mutation_evolution_effect(self):
        """Визуальный эффект эволюции мутанта"""
        # Изменение размера
        self.scaleInterval(0.5, 1.5).start()
        
        # Изменение цвета
        self.setColorInterval(0.5, (0.8, 0.2, 0.8, 1)).start()
        
        # Эффект частиц
        effect = ParticleEffect()
        effect.loadConfig("effects/mutation_evolution.ptf")
        effect.start(self)
Python



---

#### **5. Визуализация и интерфейс**

##### **5.1. Изометрическая камера**
```python
from panda3d.core import *
from direct.showbase.ShowBase import ShowBase

class IsometricCamera:
    def __init__(self, showbase):
        self.showbase = showbase
        self.camera = showbase.camera
        self.target = None
        
        # Настройка изометрической проекции
        self.lens = OrthographicLens()
        self.lens.setFilmSize(20, 15)
        self.camera.node().setLens(self.lens)
        
        # Позиционирование камеры
        self.camera.setPos(15, -15, 15)
        self.camera.lookAt(0, 0, 0)
        
        # Управление камерой
        self.showbase.accept("c", self.toggle_follow)
        self.showbase.accept("space", self.center_on_target)
        
    def toggle_follow(self):
        """Переключение режима следования"""
        self.follow_target = not self.follow_target
        
    def center_on_target(self):
        """Центрирование на цели"""
        if self.target:
            self.camera.lookAt(self.target)
            
    def update(self, dt):
        """Обновление камеры"""
        if self.follow_target and self.target:
            # Плавное следование
            target_pos = self.target.getPos()
            current_pos = self.camera.getPos()
            new_pos = current_pos + (target_pos - current_pos) * 0.1
            self.camera.setPos(new_pos)

##### 5.2. HUD игры
```python
class HUD:
    def __init__(self, screen, player):
        self.screen = screen
        self.player = player
        self.font = loader.loadFont("fonts/arial.egg")
        
        # Создание элементов HUD
        self.create_health_bar()
        self.create_memory_indicator()
        self.create_emotion_display()
        self.create_skill_bar()
        
    def create_memory_indicator(self):
        """Индикатор уровня памяти"""
        self.mem
ory_text = OnscreenText(
            text=f"Memory Level: {self.player.memory_system.get_memory_level()}",
            pos=(-1.3, 0.8),
            scale=0.05,
            fg=(1, 1, 1, 1)
        )
        
    def update_memory_indicator(self):
        """Обновление индикатора памяти"""
        level = self.player.memory_system.get_memory_level()
        self.memory_text.setText(f"Memory Level: {level}")
        
    def draw(self):
        """Отрисовка HUD"""
        # Обновление всех элементов
        self.update_health_bar()
        self.update_memory_indicator()
        self.update_emotion_display()
        self.update_skill_bar()
```

```

---

#### 7. Заключение
Представленный проект "Эволюционная Адаптация: Генетический Резонанс" с использованием Panda3D обеспечивает:
1. Полную реализацию всех запрошенных механик
2. Многофазовые бои с уникальными скиллами для боссов и мутантов
3. Систему памяти с персональным и общим опытом
4. Обучение ИИ использованию скиллов на основе опыта
5. Оптимизированную производительность для сложных игровых систем
6. Модульную архитектуру для легкого расширения
7. Полноценный UI со всеми необходимыми меню и HUD

Все системы интегрированы в единую экосистему, где прогрессия персонажа и эволюция врагов напрямую влияют на игровой процесс, создавая динамичный и адаптивный игровой опыт. Базовые классы, такие как Item, и системы эффектов, скиллов и урона обеспечивают гибкую и расширяемую основу для развития игры.
все системы должны быть интегрированы в структуру игры, не удаляй функциональность . все изменения производи в уже созданных файлахЮ что бы не плодить модули дублирующие функционал, но если нужно что то вынести в новый модуль выноси