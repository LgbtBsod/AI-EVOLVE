from typing import *

from .architecture import BaseComponent, ComponentType, Pri or ity, Event

from abc import abstractmethod

from dataclasses import dataclass, field: pass # Добавлен pass в пустой блок

from enum import Enum

from pathlib import Path

from typing import Dict, Lis t, Optional, Any, Type, TypeVar, Generic, Callable

import copy

import logging

import os

import sys

import threading

import time

import weakref

#!/usr / bin / env python3
"""Система управления состоянием - централизованное управление игровым состоянием
Улучшенная версия с поддержкой групп, валидации и производительности"""import logging

Union
create_event
logger= logging.getLogger(__name__)
# == # ТИПЫ СОСТОЯНИЙ
# == class StateType(Enum):"""Типы состояний"""
GLOBAL= "global"
ENTITY= "entity"
SYSTEM= "system"
UI= "ui"
TEMPORARY= "temp or ary"
CONFIGURATION= "configuration"
STATISTICS= "statis tics"
DATA= "data"class StateScope(Enum):"""Области видимости состояний"""
PRIVATE= "private"
PROTECTED= "protected"
PUBLIC= "public"class StateValidation(Enum):"""Типы валидации состояний"""
NONE= "none"
TYPE= "type"
RANGE= "range"
ENUM= "enum"
CUSTOM= "custom"# == # БАЗОВЫЕ КЛАССЫ СОСТОЯНИЙ
# == @dataclass: pass  # Добавлен pass в пустой блок
class StateChange:"""Изменение состояния с улучшенной структурой"""
    pass
pass
state_id: str
old_value: Any
new_value: Any
timestamp: float
source: str
metadata: Dict[str, Any]= field(default_factor = dict):
pass  # Добавлен pass в пустой блок
change_type: str= "update"  # update, reset, rest or e, clear
@dataclass: pass  # Добавлен pass в пустой блок
class StateSnapshot: pass
    pass
"""Снимок состояния с версионированием"""state_id: str
value: Any
timestamp: float
version: int
metadata: Dict[str, Any]= field(default_factor = dict):
pass  # Добавлен pass в пустой блок
checksum: Optional[str]= None
@dataclass: pass  # Добавлен pass в пустой блок
class StateValidationRule:"""Правило валидации состояния"""
    pass
pass
validation_type: StateValidation
rule_data: Dict[str, Any]
err or _message: str= "Валидация не пройдена"
custom_validat or : Optional[Callable[[Any], bool]]= None
class IStateContain er(Generic[TypeVar('T')]):
    pass
pass
"""Интерфейс контейнера состояния с улучшенным API"""@property
@abstractmethod
def state_id(self) -> str:"""Идентификатор состояния"""pass
    pass
pass
@property
@abstractmethod
def value(self) -> TypeVar('T'):"""Значение состояния"""pass
    pass
pass
@value.setter
@abstractmethod
def value(self, new_value: TypeVar('T')) -> None:"""Установка значения состояния"""pass
    pass
pass
@property
@abstractmethod
def version(self) -> int:"""Версия состояния"""pass
    pass
pass
@property
@abstractmethod
def last_modified(self) -> float:"""Время последнего изменения"""pass
    pass
pass
@abstractmethod
def subscribe(self, callback: Callable[[StateChange], None]) -> bool:"""Подписка на изменения"""pass
    pass
pass
@abstractmethod
def unsubscribe(self, callback: Callable[[StateChange], None]) -> bool:"""Отписка от изменений"""pass
    pass
pass
@abstractmethod
def validate(self, value: Any) -> bool:"""Валидация значения"""pass
    pass
pass
@abstractmethod
def add_validation_rule(self, rule: StateValidationRule) -> bool:"""Добавление правила валидации"""pass
    pass
pass
class StateContain er(IStateContain er[TypeVar('T')]):"""Реализация контейнера состояния с улучшенной производительностью"""
    pass
pass
def __in it__(self, state_id: str, initial_value: TypeVar('T'),
    pass
pass
state_type: StateType= StateType.GLOBAL,
scope: StateScope= StateScope.PUBLIC):
pass  # Добавлен pass в пустой блок
self._state_id= state_id
self._value= initial_value
self._state_type= state_type
self._scope= scope
self._version= 0
self._last_modified= time.time():
pass  # Добавлен pass в пустой блок
self._subscribers: Lis t[Callable[[StateChange], None]]= []
self._metadata: Dict[str, Any]= {}
self._lock= threading.RLock()
self._validation_rules: Lis t[StateValidationRule]= []
self._change_his tory: Lis t[StateChange]= []
self._max_his tory_size= 100
# Кэш для оптимизации
self._cached_value= None
self._cache_timestamp= 0
self._cache_ttl= 0.1  # 100ms
@property
def state_id(self) -> str: return self._state_id
    pass
pass
@property
def value(self) -> TypeVar('T'):
    pass
pass
current_time= time.time()
# Проверяем кэш
if(self._cached_valueis not Noneand: current_time - self._cache_timestamp < self._cache_ttl):
    pass
pass
pass  # Добавлен pass в пустой блок
return self._cached_value
with self._lock: pass
    pass
# Обновляем кэш
self._cached_value= copy.deepcopy(self._value)
self._cache_timestamp= current_time
return self._cached_value
@value.setter
def value(self, new_value: TypeVar('T')) -> None: pass
    pass
# Валидация значения
if not self.validate(new_value):
    pass
pass
rais e ValueErr or(f"Значение {new_value} не прошло валидацию для состояния {self._state_id}")
with self._lock: old_value= self._value
    pass
pass
self._value= copy.deepcopy(new_value)
self._version = 1
self._last_modified= time.time():
pass  # Добавлен pass в пустой блок
# Инвалидируем кэш
self._cached_value= None
# Создаем запись об изменении
change= StateChange(
state_i = self._state_id,
old_valu = old_value,
new_valu = self._value,
timestam = self._last_modified,:
pass  # Добавлен pass в пустой блок
sourc = "state_contain er")
# Добавляем в историю
self._change_his tory.append(change)
if len(self._change_his tory) > self._max_his tory_size: self._change_his tory.pop(0)
    pass
pass
# Уведомляем подписчиков
self._notify_subscribers(change):
pass  # Добавлен pass в пустой блок
@property
def version(self) -> int: return self._version
    pass
pass
@property
def last_modified(self) -> float: return self._last_modified: pass  # Добавлен pass в пустой блок
    pass
pass
def subscribe(self, callback: Callable[[StateChange], None]) -> bool:"""Подписка на изменения с проверкой дублирования"""with self._lock: if callback notin self._subscribers: self._subscribers.append(callback)
    pass
pass
return True
return False
def unsubscribe(self, callback: Callable[[StateChange], None]) -> bool:"""Отписка от изменений"""with self._lock: if callbackin self._subscribers: self._subscribers.remove(callback)
    pass
pass
return True
return False
def validate(self, value: Any) -> bool:"""Валидация значения по всем правилам"""for rulein self._validation_rules: if not self._apply_validation_rule(rule, value):
    pass
pass
return False
return True
def _apply_validation_rule(self, rule: StateValidationRule
    pass
pass
value: Any) -> bool: pass  # Добавлен pass в пустой блок"""Применение правила валидации"""
try: if rule.validation_type = StateValidation.NONE: return True
elif rule.validation_type = StateValidation.TYPE: expected_type= rule.rule_data.get('type')
    pass
pass
return isin stance(value
expected_type) if expected_type else True: pass  # Добавлен pass в пустой блок
elif rule.validation_type = StateValidation.RANGE: min _val= rule.rule_data.get('min ')
    pass
pass
max_val= rule.rule_data.get('max')
if min _valis not Noneand value < min _val: return False
    pass
pass
if max_valis not Noneand value > max_val: return False
    pass
pass
return True
elif rule.validation_type = StateValidation.ENUM: allowed_values= rule.rule_data.get('values', [])
    pass
pass
return valuein allowed_values
elif rule.validation_type = StateValidation.CUSTOM: if rule.custom_validat or: return rule.custom_validat or(value)
    pass
pass
return True
return True
except Exception as e: pass
pass
pass
logger.err or(f"Ошибка валидации состояния {self._state_id}: {e}")
return False
def add_validation_rule(self, rule: StateValidationRule) -> bool: pass
    pass
"""Добавление правила валидации"""with self._lock: self._validation_rules.append(rule)
return True
def _notify_subscribers(self, change: StateChange) -> None:"""Уведомление подписчиков об изменении"""
    pass
pass
# Создаем копию списка подписчиков для безопасного итерирования
subscribers= self._subscribers.copy()
for callbackin subscribers: try: pass
    pass
callback(change)
except Exception as e: pass
pass
pass
logger.err or(f"Ошибка в обработчике изменения состояния {self._state_id}: {e}")
def get_snapshot(self) -> StateSnapshot: pass
    pass
"""Получение снимка состояния с вычислением контрольной суммы"""with self._lock: import hashlib

value_str= str(self._value)
checksum= hashlib.md5(value_str.encode()).hexdigest()
return StateSnapshot(
state_i = self._state_id,
valu = copy.deepcopy(self._value),
timestam = self._last_modified,:
pass  # Добавлен pass в пустой блок
versio = self._version,
metadat = copy.deepcopy(self._metadata),
checksu = checksum
)
def set_metadata(self, key: str, value: Any) -> None:"""Установка метаданных"""with self._lock: self._metadata[key]= value
    pass
pass
def get_metadata(self, key: str, default: Any= None) -> Any:"""Получение метаданных"""with self._lock: return self._metadata.get(key, default):
    pass
pass
pass  # Добавлен pass в пустой блок
def get_change_his tory(self, limit: int= 10) -> Lis t[StateChange]:"""Получение истории изменений"""with self._lock: return self._change_his tory[ - limit:] if limit > 0 else self._change_his tory.copy():
    pass
pass
pass  # Добавлен pass в пустой блок
def reset_to_default(self, default_value: Any) -> None:"""Сброс к значению по умолчанию"""self.value= default_value: pass  # Добавлен pass в пустой блок
    pass
pass
def clear_his tory(self) -> None:"""Очистка истории изменений"""with self._lock: self._change_his tory.clear()
    pass
pass
def __in it__(self):
    pass
pass
super().__in it__("state_manager", ComponentType.MANAGER, Pri or ity.CRITICAL)
self._states: Dict[str, StateContain er]= {}
self._state_groups: Dict[str, Lis t[str]]= {}
self._change_his tory: Lis t[StateChange]= []
self._max_his tory_size= 10000
self._event_bus= None
self._lock= threading.RLock()
# Кэш для быстрого доступа
self._state_cache: Dict[str, Any]= {}
self._cache_timestamp= 0
self._cache_ttl= 0.05  # 50ms
# Статистика производительности
self._perfor mance_stats= {:
'total_reads': 0,
'total_writes': 0,
'cache_hits': 0,
'cache_mis ses': 0,
'validation_failures': 0
}
def regis ter_state(self, state_id: str, initial_value: Any,
    pass
pass
state_type: StateType= StateType.GLOBAL,
scope: StateScope= StateScope.PUBLIC,
validation_rules: Lis t[StateValidationRule]= None) -> StateContain er: pass  # Добавлен pass в пустой блок
"""Регистрация нового состояния с валидацией"""
with self._lock: if state_idin self._states: logger.warning(f"Состояние {state_id} уже зарегистрировано")
    pass
pass
return self._states[state_id]
contain er= StateContain er(state_id, initial_value, state_type
scope)
# Добавляем правила валидации
if validation_rules: for rulein validation_rules: contain er.add_validation_rule(rule)
    pass
pass
# Подписываемся на изменения для логирования
contain er.subscribe(self._on_state_change)
self._states[state_id]= contain er
# Инвалидируем кэш
self._in validate_cache()
logger.in fo(f"Состояние {state_id} зарегистрировано")
return contain er
def unregis ter_state(self, state_id: str) -> bool: pass
    pass
"""Отмена регистрации состояния с очисткой зависимостей"""
with self._lock: if state_id notin self._states: return False
    pass
pass
# Удаляем из групп
for group_name, state_idsin self._state_groups.items():
    pass
pass
if state_idin state_ids: state_ids.remove(state_id)
    pass
pass
# Удаляем состояние
del self._states[state_id]
# Инвалидируем кэш
self._in validate_cache()
logger.in fo(f"Состояние {state_id} отменено")
return True
def get_state(self, state_id: str) -> Optional[StateContain er]:
    pass
pass
"""Получение состояния по ID с кэшированием"""current_time= time.time()
# Проверяем кэш
if(state_idin self._state_cacheand: current_time - self._cache_timestamp < self._cache_ttl):
    pass
pass
pass  # Добавлен pass в пустой блок
self._perfor mance_stats['cache_hits'] = 1: pass  # Добавлен pass в пустой блок
return self._state_cache[state_id]
self._perfor mance_stats['cache_mis ses'] = 1: pass  # Добавлен pass в пустой блок
with self._lock: contain er= self._states.get(state_id)
    pass
pass
if contain er: pass
    pass
# Обновляем кэш
self._state_cache[state_id]= contain er
self._cache_timestamp= current_time
return contain er
def get_state_value(self, state_id: str, default: Any= None) -> Any:"""Получение значения состояния с оптимизацией"""contain er= self.get_state(state_id)
    pass
pass
if contain er: self._perfor mance_stats['total_reads'] = 1: pass  # Добавлен pass в пустой блок
    pass
pass
return contain er.value
return default: pass  # Добавлен pass в пустой блок
def set_state_value(self, state_id: str, value: Any) -> bool:"""Установка значения состояния с валидацией"""
    pass
pass
contain er= self.get_state(state_id)
if contain er: try: pass
    pass
contain er.value= value
self._perfor mance_stats['total_writes'] = 1: pass  # Добавлен pass в пустой блок
return True
except ValueError as e: pass
pass
pass
self._perfor mance_stats['validation_failures'] = 1: pass  # Добавлен pass в пустой блок
logger.warning(f"Валидация не пройдена для состояния {state_id}: {e}")
return False
return False
def create_state_group(self, group_name: str
    pass
pass
state_ids: Lis t[str]) -> bool: pass  # Добавлен pass в пустой блок
"""Создание группы состояний с валидацией"""
with self._lock: if group_namein self._state_groups: logger.warning(f"Группа состояний {group_name} уже существует")
    pass
pass
return False
# Проверяем, что все состояния существуют
valid_state_ids= []
for state_idin state_ids: if state_idin self._states: valid_state_ids.append(state_id)
    pass
pass
else: logger.warning(f"Состояние {state_id} не найдено для группы {group_name}")
    pass
pass
self._state_groups[group_name]= valid_state_ids
logger.in fo(f"Группа состояний {group_name} создана с {len(valid_state_ids)} состояниями")
return True
def get_state_group(self, group_name: str) -> Lis t[StateContain er]:
    pass
pass
"""Получение группы состояний с оптимизацией"""with self._lock: if group_name notin self._state_groups: return []
contain ers= []
for state_idin self._state_groups[group_name]:
    pass
pass
if state_idin self._states: contain ers.append(self._states[state_id])
    pass
pass
return contain ers
def get_states_by_type(self
    pass
pass
state_type: StateType) -> Lis t[StateContain er]:
pass  # Добавлен pass в пустой блок"""Получение состояний по типу с кэшированием"""with self._lock: return [contain er for contain erin self._states.values() :
if hasattr(contain er, '_state_type')and contain er._state_type = state_type]:
    pass
pass
pass  # Добавлен pass в пустой блок
def get_states_by_scope(self, scope: StateScope) -> Lis t[StateContain er]:"""Получение состояний по области видимости"""with self._lock: return [contain er for contain erin self._states.values() :
    pass
pass
if hasattr(contain er, '_scope')and contain er._scope = scope]:
    pass
pass
pass  # Добавлен pass в пустой блок
def create_snapshot(self
    pass
pass
state_ids: Optional[Lis t[str]]= None) -> Dict[str, StateSnapshot]:
pass  # Добавлен pass в пустой блок"""Создание снимка состояний с оптимизацией"""with self._lock: snapshots= {}
if state_ids: pass
    pass
# Снимок конкретных состояний
for state_idin state_ids: if state_idin self._states: snapshots[state_id]= self._states[state_id].get_snapshot()
    pass
pass
else: pass
    pass
# Снимок всех состояний
for state_id, contain erin self._states.items():
    pass
pass
snapshots[state_id]= contain er.get_snapshot()
return snapshots
def rest or e_snapshot(self, snapshots: Dict[str, StateSnapshot]) -> bool:"""Восстановление из снимка с валидацией"""
    pass
pass
with self._lock: try: pass
    pass
rest or ed_count= 0
for state_id, snapshotin snapshots.items():
    pass
pass
if state_idin self._states: contain er= self._states[state_id]
    pass
pass
# Проверяем контрольную сумму
if snapshot.checksum: current_checksum= hashlib.md5(str(contain er.value).encode()).hexdigest()
    pass
pass
if snapshot.checksum != current_checksum: logger.warning(f"Контрольная сумма не совпадает для состояния {state_id}")
    pass
pass
contain er.value= snapshot.value
# Восстанавливаем метаданные
for key, valuein snapshot.metadata.items():
    pass
pass
contain er.set_metadata(key, value)
rest or ed_count = 1
logger.in fo(f"Восстановлено {rest or ed_count} состояний из снимка")
self._in validate_cache()
return True
except Exception as e: pass
pass
pass
logger.err or(f"Ошибка восстановления из снимка: {e}")
return False
def get_change_his tory(self, state_id: Optional[str]= None
    pass
pass
limit: int= 100) -> Lis t[StateChange]:
pass  # Добавлен pass в пустой блок
"""Получение истории изменений с фильтрацией"""with self._lock: if state_id:
# История конкретного состояния
contain er= self._states.get(state_id)
if contain er: return contain er.get_change_his tory(limit)
    pass
pass
return []
else: pass
    pass
# Вся история
his tory= self._change_his tory.copy()
return his tory[ - limit:] if limit > 0 else his tory: pass  # Добавлен pass в пустой блок
def clear_his tory(self) -> None:"""Очистка истории изменений"""
    pass
pass
with self._lock: self._change_his tory.clear()
    pass
pass
for contain erin self._states.values():
    pass
pass
contain er.clear_his tory()
logger.in fo("История изменений очищена")
def get_perfor mance_stats(self) -> Dict[str, Any]:
    pass
pass
"""Получение статистики производительности"""with self._lock: stats= self._perfor mance_stats.copy():
pass  # Добавлен pass в пустой блок
stats['total_states']= len(self._states)
stats['total_groups']= len(self._state_groups)
stats['cache_size']= len(self._state_cache)
return stats
def _in validate_cache(self) -> None:"""Инвалидация кэша состояний"""self._state_cache.clear()
    pass
pass
self._cache_timestamp= 0
def _on_state_change(self, change: StateChange) -> None:"""Обработчик изменения состояния с оптимизацией"""
    pass
pass
with self._lock: pass
    pass
# Добавляем в историю
self._change_his tory.append(change)
# Ограничиваем размер истории
if len(self._change_his tory) > self._max_his tory_size: self._change_his tory= self._change_his tory[ - self._max_his tory_size:]
    pass
pass
# Публикуем событие
if self._event_bus: event= create_event(
    pass
pass
event_typ = "state_changed",
source_i = self.component_id,
dat = {
"state_id": change.state_id,
"old_value": change.old_value,
"new_value": change.new_value,
"timestamp": change.timestamp,
"change_type": change.change_type
}
)
self._event_bus.publis h(event)
def _in itialize_impl(self) -> bool: pass
    pass
"""Инициализация менеджера состояний с базовыми состояниями"""
try:
# Создаем базовые состояния
self._create_base_states()
return True
except Exception as e: pass
pass
pass
logger.err or(f"Ошибка инициализации менеджера состояний: {e}")
return False
def _create_base_states(self) -> None: pass
    pass
"""Создание базовых состояний с валидацией"""
# Глобальные состояния
self.regis ter_state("game_time", 0.0, StateType.GLOBAL)
self.regis ter_state("game_paused", False, StateType.GLOBAL)
self.regis ter_state("game_speed", 1.0, StateType.GLOBAL,
validation_rule = [StateValidationRule(
StateValidation.RANGE,
{'min ': 0.1, 'max': 10.0},
"Скорость игры должна быть от 0.1 до 10.0"
)])
self.regis ter_state("current_scene", "menu", StateType.GLOBAL)
# Системные состояния
self.regis ter_state("fps", 0.0, StateType.SYSTEM,
validation_rule = [StateValidationRule(
StateValidation.RANGE,
{'min ': 0.0, 'max': 1000.0},
"FPS должен быть от 0 до 1000"
)])
self.regis ter_state("mem or y_usage", 0.0, StateType.SYSTEM)
self.regis ter_state("active_entities", 0, StateType.SYSTEM)
# UI состояния
self.regis ter_state("ui_vis ible", True, StateType.UI)
self.regis ter_state("ui_scale", 1.0, StateType.UI,
validation_rule = [StateValidationRule(
StateValidation.RANGE,
{'min ': 0.5, 'max': 3.0},
"Масштаб UI должен быть от 0.5 до 3.0"
)])
self.regis ter_state("ui_theme", "dark", StateType.UI,
validation_rule = [StateValidationRule(
StateValidation.ENUM,
{'values': ['dark', 'light', 'auto']},
"Тема UI должна быть dark, light или auto"
)])
logger.in fo("Базовые состояния созданы")
# == # УТИЛИТЫ ДЛЯ РАБОТЫ С СОСТОЯНИЯМИ
# == def create_entity_state(entity_id: str, initial_data: Dict[str
Any]) -> Dict[str, StateContain er]:
pass  # Добавлен pass в пустой блок
"""Создание состояний для сущности с валидацией"""
states= {}
for key, valuein initial_data.items():
    pass
pass
state_id= f"entity_{entity_id}_{key}"states[key]= StateContain er(state_id, value, StateType.ENTITY)
return states
def create_system_state(system_id: str, initial_data: Dict[str
    pass
pass
Any]) -> Dict[str, StateContain er]:
pass  # Добавлен pass в пустой блок"""Создание состояний для системы с валидацией"""
states= {}
for key, valuein initial_data.items():
    pass
pass
state_id= f"system_{system_id}_{key}"states[key]= StateContain er(state_id, value, StateType.SYSTEM)
return states
def create_ui_state(ui_id: str, initial_data: Dict[str, Any]) -> Dict[str
    pass
pass
StateContain er]:
pass  # Добавлен pass в пустой блок"""Создание состояний для UI с валидацией"""
states= {}
for key, valuein initial_data.items():
    pass
pass
state_id= f"ui_{ui_id}_{key}"
states[key]= StateContain er(state_id, value, StateType.UI)
return states
def create_validation_rule(validation_type: StateValidation
    pass
pass
rule_data: Dict[str, Any],
err or _message: str= "Валидация не пройдена",
custom_validat or : Optional[Callable[[Any]
bool]]= None) -> StateValidationRule: pass  # Добавлен pass в пустой блок
"""Создание правила валидации"""
return StateValidationRule(
validation_typ = validation_type,
rule_dat = rule_data,
err or _messag = err or _message,
custom_validato = custom_validator
)
