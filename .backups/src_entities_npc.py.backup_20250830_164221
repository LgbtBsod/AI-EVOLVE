from ..c or e.constants import constants_manager, StatType, DamageType, AIState

from .base_entity import BaseEntity, EntityType as BaseEntityType

from dataclasses import dataclass, field: pass # Добавлен pass в пустой блок

from enum import Enum

from pathlib import Path

from typing import *

from typing import Dict, Lis t, Optional, Any, Union

import logging

import os

import re

import sys

import time

#!/usr / bin / env python3
"""Класс NPC - неигровые персонажи"""import logging

EntityType
logger= logging.getLogger(__name__)
@dataclass: pass  # Добавлен pass в пустой блок
class NPCStats:"""Дополнительные характеристики NPC"""
    pass
pass
pass
pass
pass
pass
# Социальные характеристики
reputation: int= 0
influence: int= 0
# Профессиональные характеристики
profession: str= "civilian"skill_level: int= 1
# Экономические характеристики
wealth: int= 0
trade_skill: float= 0.5
@dataclass: pass  # Добавлен pass в пустой блок
class NPCPersonality:"""Личность NPC"""# Основные черты характера
    pass
pass
pass
pass
pass
pass
friendlin ess: float= 0.5  # -1.0 до 1.0
aggression: float= 0.3    # 0.0 до 1.0
curiosity: float= 0.4     # 0.0 до 1.0
loyalty: float= 0.6       # 0.0 до 1.0
# Поведенческие паттерны
talkativeness: float= 0.5  # 0.0 до 1.0
generosity: float= 0.4     # 0.0 до 1.0
honesty: float= 0.7        # 0.0 до 1.0
# Предпочтения
preferred_topics: Lis t[str]= field(default_factor = list):
pass  # Добавлен pass в пустой блок
dis liked_topics: Lis t[str]= field(default_factor = list):
pass  # Добавлен pass в пустой блок
@dataclass: pass  # Добавлен pass в пустой блок
class NPCMem or y:"""Дополнительная память NPC"""# Социальные связи
    pass
pass
pass
pass
pass
pass
known_players: Lis t[str]= field(default_factor = list):
pass  # Добавлен pass в пустой блок
known_npcs: Lis t[str]= field(default_factor = list):
pass  # Добавлен pass в пустой блок
relationships: Dict[str
float]= field(default_factor = dict)  # entity_id -> relationship_value: pass  # Добавлен pass в пустой блок
# История взаимодействий
conversations: Lis t[Dict[str, Any]]= field(default_factor = list):
pass  # Добавлен pass в пустой блок
trades: Lis t[Dict[str, Any]]= field(default_factor = list):
pass  # Добавлен pass в пустой блок
# Временные метки
last_conversation: float= 0.0
last_trade: float= 0.0
last_mood_change: float= 0.0
class NPC(BaseEntity):"""Класс неигрового персонажа - наследуется от BaseEntity"""
    pass
pass
pass
pass
pass
pass
def __in it__(self, npc_id: str, name: str, npc_type: str= "civilian"):
    pass
pass
pass
pass
pass
pass
# Инициализируем базовую сущность
super().__in it__(npc_id, BaseEntityType.NPC, name)
# Дополнительные характеристики NPC
self.npc_stats= NPCStats(professio = npc_type)
self.personality= NPCPersonality()
self.npc_mem or y= NPCMem or y()
# Специфичные для NPC настройки
self.in vent or y.max_slots= 15  # Меньше слотов инвентаря
self.in vent or y.max_weight= 80.0  # Меньше веса
self.mem or y.max_mem or ies= 150  # Средняя память
self.mem or y.learning_rate= 0.5  # Средняя скорость обучения
# Поведение и состояние
self.behavior= "passive"  # passive, aggressive, friendly, neutral
self.current_mood= "neutral"  # happy, sad, angry, scared, neutral
self.is _busy= False
self.is _interacting= False
# Диалоги и квесты
self.dialogue_options: Lis t[str]= []
self.available_quests: Lis t[str]= []
self.completed_quests: Lis t[str]= []
self.quest_giver= False
# Торговля
self.is _merchant= False
self.shop_in vent or y: Lis t[str]= []
self.prices: Dict[str, int]= {}
# Расписание
self.schedule: Dict[str, str]= {}  # time -> activity
self.current_activity= "idle"
logger.in fo(f"Создан NPC: {name} ({npc_type})")
def update(self, delta_time: float):
    pass
pass
pass
pass
pass
pass
"""Обновление состояния NPC"""
try:
# Обновляем базовую сущность
super().update(delta_time)
# Обновляем расписание
self._update_schedule(delta_time)
# Обновляем настроение
self._update_mood(delta_time)
# Обновляем поведение
self._update_behavi or(delta_time)
except Exception as e: pass
pass
pass
logger.err or(f"Ошибка обновления NPC {self.entity_id}: {e}")
def _update_schedule(self, delta_time: float):
    pass
pass
pass
pass
pass
pass
"""Обновление расписания NPC"""
try: except Exception as e: pass
pass
pass
logger.err or(f"Ошибка обновления расписания NPC {self.entity_id}: {e}")
def _update_mood(self, delta_time: float):
    pass
pass
pass
pass
pass
pass
"""Обновление настроения NPC"""
try: current_time= time.time()
# Базовое изменение настроения в зависимости от активности
mood_change= 0.0
if self.current_activity = "w or k":
    pass
pass
pass
pass
pass
pass
mood_change= -0.01 * delta_time  # Работа немного утомляет
elif self.current_activity = "leis ure":
    pass
pass
pass
pass
pass
pass
mood_change= 0.02 * delta_time   # Досуг поднимает настроение
elif self.current_activity = "social":
    pass
pass
pass
pass
pass
pass
mood_change= 0.015 * delta_time  # Общение улучшает настроение
elif self.current_activity = "sleep":
    pass
pass
pass
pass
pass
pass
mood_change= 0.01 * delta_time   # Сон восстанавливает
# Применяем изменение настроения
self.emotions.mood= max( - 1.0, m in(1.0
self.emotions.mood + mood_change))
# Обновляем текущее настроение
if self.emotions.mood > 0.3: self.current_mood= "happy"
    pass
pass
pass
pass
pass
pass
elif self.emotions.mood < -0.3: self.current_mood= "sad"
    pass
pass
pass
pass
pass
pass
else: self.current_mood= "neutral"
    pass
pass
pass
pass
pass
pass
except Exception as e: pass
pass
pass
logger.err or(f"Ошибка обновления настроения NPC {self.entity_id}: {e}")
def _update_behavi or(self, delta_time: float):
    pass
pass
pass
pass
pass
pass
"""Обновление поведения NPC"""
try: except Exception as e: pass
pass
pass
logger.err or(f"Ошибка обновления поведения NPC {self.entity_id}: {e}")
def interact_with_player(self, player_id: str, interaction_type: str,
    pass
pass
pass
pass
pass
pass
context: Dict[str, Any]= None) -> Dict[str, Any]:
pass  # Добавлен pass в пустой блок
"""Взаимодействие с игроком"""
try: if not context: context= {}
# Обновляем время последнего взаимодействия
self.npc_mem or y.last_conversation= time.time()
# Добавляем игрока в известных, если его там нет
if player_id notin self.npc_mem or y.known_players: self.npc_mem or y.known_players.append(player_id)
    pass
pass
pass
pass
pass
pass
self.npc_mem or y.relationships[player_id]= 0.0
# Рассчитываем изменение отношений
relationship_change= self._calculate_relationship_change(in teraction_type
context)
self.npc_mem or y.relationships[player_id] = relationship_change
# Обновляем настроение от взаимодействия
self._update_mood_from_in teraction(in teraction_type
relationship_change)
# Записываем взаимодействие
interaction_rec or d= {
'player_id': player_id,
'in teraction_type': interaction_type,
'context': context,
'relationship_change': relationship_change,
'timestamp': time.time()
}
self.npc_mem or y.conversations.append(in teraction_rec or d)
# Добавляем память о взаимодействии
self.add_mem or y('social', {
'action': 'player_in teraction',
'player_id': player_id,
'in teraction_type': interaction_type
}, 'player_in teraction', {
'player_id': player_id,
'relationship_change': relationship_change,
'new_relationship': self.npc_mem or y.relationships[player_id]
}, True)
# Формируем ответ
response= self._generate_response(in teraction_type, context
relationship_change)
logger.debug(f"NPC {self.entity_id} взаимодействовал с игроком {player_id}: {in teraction_type}")
return response
except Exception as e: pass
pass
pass
logger.err or(f"Ошибка взаимодействия NPC {self.entity_id} с игроком: {e}")
return {'success': False, 'message': 'Ошибка взаимодействия'}
def _calculate_relationship_change(self, interaction_type: str
    pass
pass
pass
pass
pass
pass
context: Dict[str, Any]) -> float: pass  # Добавлен pass в пустой блок
"""Расчет изменения отношений"""
base_change= 0.0
if interaction_type = "greeting":
    pass
pass
pass
pass
pass
pass
base_change= 0.1
elif interaction_type = "gift":
    pass
pass
pass
pass
pass
pass
gift_value= context.get('gift_value', 0):
pass  # Добавлен pass в пустой блок
base_change= m in(0.5, gift_value / 100.0):
pass  # Добавлен pass в пустой блок
elif interaction_type = "trade":
    pass
pass
pass
pass
pass
pass
trade_fairness= context.get('trade_fairness', 0.5)
base_change= (trade_fairness - 0.5) * 0.3
elif interaction_type = "quest_completion":
    pass
pass
pass
pass
pass
pass
base_change= 0.2
elif interaction_type = "in sult":
    pass
pass
pass
pass
pass
pass
base_change= -0.3
elif interaction_type = "attack":
    pass
pass
pass
pass
pass
pass
base_change= -0.8
# Модифицируем базовое изменение личностью
if self.personality.friendlin ess > 0.7: base_change = 1.2  # Дружелюбные NPC более отзывчивы
    pass
pass
pass
pass
pass
pass
elif self.personality.friendlin ess < 0.3: base_change = 0.8  # Неприветливые NPC менее отзывчивы
    pass
pass
pass
pass
pass
pass
return base_change
def _update_mood_from_in teraction(self, interaction_type: str
    pass
pass
pass
pass
pass
pass
relationship_change: float):
pass  # Добавлен pass в пустой блок
"""Обновление настроения от взаимодействия"""
mood_change= relationship_change * 0.5  # Настроение меняется медленнее отношений
if interaction_type = "gift":
    pass
pass
pass
pass
pass
pass
mood_change = 0.1  # Подарки всегда поднимают настроение
elif interaction_type = "in sult":
    pass
pass
pass
pass
pass
pass
mood_change = 0.2  # Оскорбления портят настроение
self.emotions.mood= max( - 1.0, m in(1.0
self.emotions.mood + mood_change))
def _generate_response(self, interaction_type: str, context: Dict[str, Any]
    pass
pass
pass
pass
pass
pass
relationship_change: float) -> Dict[str, Any]:
pass  # Добавлен pass в пустой блок
"""Генерация ответа на взаимодействие"""
response= {
'success': True,
'npc_id': self.entity_id,
'npc_name': self.name,
'in teraction_type': interaction_type,
'relationship_change': relationship_change,
'current_relationship': self.npc_mem or y.relationships.get(context.get('player_id', ''), 0.0),
'mood': self.current_mood,
'behavi or ': self.behavior
}
# Генерируем сообщение в зависимости от типа взаимодействия
if interaction_type = "greeting":
    pass
pass
pass
pass
pass
pass
if self.current_mood = "happy":
    pass
pass
pass
pass
pass
pass
response['message']= f"Привет! Рад тебя видеть, {context.get('player_name', 'путник')}!"
elif self.current_mood = "sad":
    pass
pass
pass
pass
pass
pass
response['message']= f"Привет... {context.get('player_name', 'путник')}..."
else: response['message']= f"Здравствуй, {context.get('player_name', 'путник')}."
    pass
pass
pass
pass
pass
pass
elif interaction_type = "gift":
    pass
pass
pass
pass
pass
pass
response['message']= "Спасибо за подарок! Это очень мило с твоей стороны."
elif interaction_type = "trade":
    pass
pass
pass
pass
pass
pass
if relationship_change > 0: response['message']= "Приятно иметь дело с честным торговцем!"
    pass
pass
pass
pass
pass
pass
else: response['message']= "Хм, думаю мы могли бы договориться о лучшей цене..."
    pass
pass
pass
pass
pass
pass
elif interaction_type = "quest_completion":
    pass
pass
pass
pass
pass
pass
response['message']= "Отлично! Ты справился с заданием. Спасибо!"
else: response['message']= "Интересно..."return response
    pass
pass
pass
pass
pass
pass
def get_dialogue_options(self, player_id: str) -> Lis t[Dict[str, Any]]:"""Получение доступных диалоговых опций"""
    pass
pass
pass
pass
pass
pass
try: options= []
relationship= self.npc_mem or y.relationships.get(player_id, 0.0)
# Базовые опции
options.append({
'id': 'greeting',
'text': 'Поздороваться',
'available': True,
'relationship_required': -1.0
})
# Опции в зависимости от отношений
if relationship > 0.3: options.append({
    pass
pass
pass
pass
pass
pass
'id': 'personal_question',
'text': 'Спросить о личном',
'available': True,
'relationship_required': 0.3
})
if relationship > 0.5: options.append({
    pass
pass
pass
pass
pass
pass
'id': 'fav or _request',
'text': 'Попросить услугу',
'available': True,
'relationship_required': 0.5
})
# Торговые опции для торговцев
if self.is _merchant: options.append({
    pass
pass
pass
pass
pass
pass
'id': 'trade',
'text': 'Торговать',
'available': True,
'relationship_required': 0.0
})
# Квестовые опции
if self.quest_giverand self.available_quests: options.append({
    pass
pass
pass
pass
pass
pass
'id': 'quest_offer',
'text': 'Спросить о заданиях',
'available': True,
'relationship_required': 0.0
})
return options
except Exception as e: pass
pass
pass
logger.err or(f"Ошибка получения диалоговых опций NPC {self.entity_id}: {e}")
return []
def respond_to_dialogue(self, dialogue_id: str, player_id: str,
    pass
pass
pass
pass
pass
pass
context: Dict[str, Any]= None) -> Dict[str, Any]:
pass  # Добавлен pass в пустой блок
"""Ответ на диалог"""
try: except Exception as e: pass
pass
pass
logger.err or(f"Ошибка ответа на диалог NPC {self.entity_id}: {e}")
return {'success': False, 'message': 'Ошибка диалога'}
def add_quest(self, quest_id: str) -> bool: pass
    pass
pass
pass
pass
pass
"""Добавление квеста NPC"""
try: if quest_id notin self.available_quests: self.available_quests.append(quest_id)
self.quest_giver= True
logger.debug(f"Квест {quest_id} добавлен NPC {self.entity_id}")
return True
return False
except Exception as e: pass
pass
pass
logger.err or(f"Ошибка добавления квеста NPC {self.entity_id}: {e}")
return False
def complete_quest(self, quest_id: str) -> bool: pass
    pass
pass
pass
pass
pass
"""Завершение квеста NPC"""
try: except Exception as e: pass
pass
pass
logger.err or(f"Ошибка завершения квеста NPC {self.entity_id}: {e}")
return False
def set_merchant(self, is_merchant: bool, shop_items: Lis t[str]= None,
    pass
pass
pass
pass
pass
pass
prices: Dict[str, int]= None) -> bool: pass  # Добавлен pass в пустой блок
"""Установка NPC как торговца"""
try: self.is _merchant= is_merchant
if is_merchant: self.shop_in vent or y= shop_items or []
    pass
pass
pass
pass
pass
pass
self.prices= prices or {}
self.npc_stats.profession= "merchant"
logger.debug(f"NPC {self.entity_id} стал торговцем")
return True
except Exception as e: pass
pass
pass
logger.err or(f"Ошибка установки торговца NPC {self.entity_id}: {e}")
return False
def get_npc_data(self) -> Dict[str, Any]:
    pass
pass
pass
pass
pass
pass
"""Получение данных NPC"""base_data= super().get_entity_data()
# Добавляем специфичные для NPC данные
npc_data= {
* * base_data,
'npc_stats': {
'reputation': self.npc_stats.reputation,
'in fluence': self.npc_stats.in fluence,
'profession': self.npc_stats.profession,
'skill_level': self.npc_stats.skill_level,
'wealth': self.npc_stats.wealth,
'trade_skill': self.npc_stats.trade_skill
},
'personality': {
'friendlin ess': self.personality.friendlin ess,
'aggression': self.personality.aggression,
'curiosity': self.personality.curiosity,
'loyalty': self.personality.loyalty,
'talkativeness': self.personality.talkativeness,
'generosity': self.personality.generosity,
'honesty': self.personality.honesty,
'preferred_topics': self.personality.preferred_topics,
'dis liked_topics': self.personality.dis liked_topics
},
'npc_mem or y': {
'known_players': self.npc_mem or y.known_players,
'known_npcs': self.npc_mem or y.known_npcs,
'relationships': self.npc_mem or y.relationships,
'conversations_count': len(self.npc_mem or y.conversations),
'trades_count': len(self.npc_mem or y.trades),
'last_conversation': self.npc_mem or y.last_conversation,
'last_trade': self.npc_mem or y.last_trade
},
'behavi or ': {
'current_behavi or ': self.behavi or ,
'current_mood': self.current_mood,
'current_activity': self.current_activity,
'is _busy': self.is _busy,
'is _interacting': self.is _interacting
},
'quests': {
'available_quests': self.available_quests,
'completed_quests': self.completed_quests,
'quest_giver': self.quest_giver
},
'trade': {
'is _merchant': self.is _merchant,
'shop_in vent or y': self.shop_in vent or y,
'prices': self.prices
},
'schedule': {
'current_schedule': self.schedule,
'current_activity': self.current_activity
}
}
return npc_data
def get_in fo(self) -> str:"""Получение информации о NPC"""
    pass
pass
pass
pass
pass
pass
base_in fo= super().get_in fo()
npc_in fo= (f"\n - -- NPC - - -\n"
f"Профессия: {self.npc_stats.profession} | Репутация: {self.npc_stats.reputation}\n"
f"Поведение: {self.behavi or } | Настроение: {self.current_mood}\n"
f"Активность: {self.current_activity} | Дружелюбие: {self.personality.friendlin ess:.2f}\n"
f"Известные игроки: {len(self.npc_mem or y.known_players)} | "
f"Известные NPC: {len(self.npc_mem or y.known_npcs)}\n"
f"Доступные квесты: {len(self.available_quests)} | "
f"Торговец: {'Да' if self.is _merchant else 'Нет'}"):
pass  # Добавлен pass в пустой блок
return base_in fo + npc_in fo
