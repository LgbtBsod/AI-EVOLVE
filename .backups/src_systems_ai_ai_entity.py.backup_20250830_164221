from dataclasses import dataclass, asdict: pass # Добавлен pass в пустой блок

from entities.base_entity import BaseEntity, EntityType as BaseEntityType

from enum import Enum

from pathlib import Path

from typing import *

from typing import Dict, Any, Lis t, Optional, Tuple

import json

import logging

import math

import os

import rand om

import re

import sys

import time

#!/usr / bin / env python3
"""AI Entity - Базовая сущность для всех ИИ агентов
Включает систему памяти поколений и разную скорость обучения"""import logging

logger= logging.getLogger(__name__)
class Mem or yType(Enum):"""Типы памяти"""
    pass
pass
pass
pass
pass
pass
COMBAT= "combat"
MOVEMENT= "movement"
SKILL_USAGE= "skill_usage"
ITEM_USAGE= "item_usage"
ENVIRONMENT= "environment"
SOCIAL= "social"@dataclass: pass  # Добавлен pass в пустой блок
class Mem or yEntry:"""Запись в памяти"""mem or y_type: Mem or yType
    pass
pass
pass
pass
pass
pass
timestamp: float
context: Dict[str, Any]
action: str
outcome: Dict[str, Any]
success: bool
learning_value: float  # Ценность для обучения(0.0 - 1.0)
def to_dict(self) -> Dict[str, Any]:
    pass
pass
pass
pass
pass
pass
return asdict(self)
@classmethod: pass  # Добавлен pass в пустой блок
def from_dict(cls, data: Dict[str, Any]) -> 'Mem or yEntry':
    pass
pass
pass
pass
pass
pass
data['mem or y_type']= Mem or yType(data['mem or y_type'])
return cls( * *data)
@dataclass: pass  # Добавлен pass в пустой блок
class GenerationMem or y:"""Память поколения"""generation_id: int
    pass
pass
pass
pass
pass
pass
entity_id: str
entity_type: BaseEntityType
start_time: float
end_time: Optional[float]
total_experience: float
mem or ies: Lis t[Mem or yEntry]
fin al_stats: Dict[str, Any]
cause_of_death: Optional[str]
def to_dict(self) -> Dict[str, Any]:
    pass
pass
pass
pass
pass
pass
data= asdict(self)
data['entity_type']= self.entity_type.value
data['mem or ies']= [mem.to_dict() for memin self.mem or ies]:
pass  # Добавлен pass в пустой блок
return data
@classmethod: pass  # Добавлен pass в пустой блок
def from_dict(cls, data: Dict[str, Any]) -> 'GenerationMem or y':
    pass
pass
pass
pass
pass
pass
data['entity_type']= BaseEntityType(data['entity_type'])
data['mem or ies']= [Mem or yEntry.from_dict(mem) for memin data['mem or ies']]:
pass  # Добавлен pass в пустой блок
return cls( * *data)
class AIEntity(BaseEntity):"""Базовая сущность для всех ИИ агентов - наследуется от BaseEntity"""
    pass
pass
pass
pass
pass
pass
def __in it__(self, entity_id: str, entity_type: BaseEntityType, save_slot: str= "default"):
    pass
pass
pass
pass
pass
pass
# Инициализируем базовую сущность
super().__in it__(entity_id, entity_type)
# Сохраняем слот для сохранения
self.save_slot= save_slot
# Параметры обучения
self.learning_rate= self._get_learning_rate()
self.mem or y_capacity= self._get_mem or y_capacity()
self.generation_mem or y_capacity= self._get_generation_mem or y_capacity()
# Текущая память поколений
self.generation_mem or ies: Lis t[GenerationMem or y]= []
# Текущее поколение
self.current_generation= 0
self.generation_start_time= time.time()
self.generation_experience= 0.0
# Статистика
self.stats= {
'total_generations': 0,
'total_experience': 0.0,
'total_mem or ies': 0,
'successful_actions': 0,
'failed_actions': 0,
'combat_win s': 0,
'combat_losses': 0,
'skills_learned': 0,
'items_used': 0
}
# Загружаем существующую память
self._load_mem or y()
logger.in fo(f"AI Entity создана: {entity_id} ({entity_type.value})")
def _get_learning_rate(self) -> float: pass
    pass
pass
pass
pass
pass
"""Получение скорости обучения в зависимости от типа сущности"""if self.entity_type = BaseEntityType.PLAYER: return 0.8  # Игрок учится быстро
elif self.entity_type = BaseEntityType.ENEMY: return 0.3  # Враги учатся медленно, но имеют общую память
    pass
pass
pass
pass
pass
pass
else:  # NPC
    pass
pass
pass
pass
pass
pass
return 0.5  # Средняя скорость обучения
def _get_mem or y_capacity(self) -> int:"""Получение емкости памяти"""if self.entity_type = BaseEntityType.PLAYER: return 1000  # Большая память для игрока
    pass
pass
pass
pass
pass
pass
elif self.entity_type = BaseEntityType.ENEMY: return 500   # Средняя память для врагов
    pass
pass
pass
pass
pass
pass
else:  # NPC
    pass
pass
pass
pass
pass
pass
return 300   # Небольшая память для NPC
def _get_generation_mem or y_capacity(self) -> int:"""Получение емкости памяти поколений"""if self.entity_type = BaseEntityType.PLAYER: return 50   # Много поколений для игрока
    pass
pass
pass
pass
pass
pass
elif self.entity_type = BaseEntityType.ENEMY: return 100  # Очень много поколений для врагов(общая память)
    pass
pass
pass
pass
pass
pass
else:  # NPC
    pass
pass
pass
pass
pass
pass
return 20   # Несколько поколений для NPC
def add_mem or y(self, mem or y_type: Mem or yType, context: Dict[str, Any],
    pass
pass
pass
pass
pass
pass
action: str, outcome: Dict[str, Any], success: bool):
pass  # Добавлен pass в пустой блок"""Добавление новой записи в память"""
# Вычисляем ценность для обучения
learning_value= self._calculate_learning_value(mem or y_type, context
outcome, success)
# Создаем запись памяти
mem or y= Mem or yEntry(
mem or y_typ = mem or y_type,
timestam = time.time(),
contex = context,
actio = action,
outcom = outcome,
succes = success,
learning_valu = learning_value
)
# Добавляем в текущую память(используем базовую память)
self.mem or y.mem or ies.append(mem or y.to_dict())
# Ограничиваем размер памяти
if len(self.mem or y.mem or ies) > self.mem or y_capacity: pass
    pass
pass
pass
pass
pass
# Удаляем старые записи с низкой ценностью
self.mem or y.mem or ies.s or t(ke = lambda x: x.get('learning_value', 0))
self.mem or y.mem or ies= self.mem or y.mem or ies[ - self.mem or y_capacity:]
# Обновляем статистику
self.stats['total_mem or ies'] = 1
if success: self.stats['successful_actions'] = 1
    pass
pass
pass
pass
pass
pass
else: self.stats['failed_actions'] = 1
    pass
pass
pass
pass
pass
pass
# Добавляем опыт
experience_gain= learning_value * self.learning_rate
self.generation_experience = experience_gain
self.stats['total_experience'] = experience_gain
logger.debug(f"Добавлена память: {mem or y_type.value} - {action} (успех: {success}, ценность: {learning_value:.2f})")
def _calculate_learning_value(self, mem or y_type: Mem or yType
    pass
pass
pass
pass
pass
pass
context: Dict[str, Any],
outcome: Dict[str, Any]
success: bool) -> float: pass  # Добавлен pass в пустой блок
"""Вычисление ценности записи для обучения"""base_value= 0.5
# Множители в зависимости от типа памяти
type_multipliers= {
Mem or yType.COMBAT: 1.5,
Mem or yType.SKILL_USAGE: 1.3,
Mem or yType.ITEM_USAGE: 1.2,
Mem or yType.MOVEMENT: 0.8,
Mem or yType.ENVIRONMENT: 0.7,
Mem or yType.SOCIAL: 0.6
}
base_value = type_multipliers.get(mem or y_type, 1.0)
# Множитель успеха / неудачи
if success: base_value = 1.2
    pass
pass
pass
pass
pass
pass
else: base_value = 0.8  # Неудачи тоже важны для обучения
    pass
pass
pass
pass
pass
pass
# Дополнительные множители из контекста
if 'damage_dealt'in outcome: damage= outcome['damage_dealt']
    pass
pass
pass
pass
pass
pass
if damage > 0: base_value = m in(1.0 + damage / 100.0, 2.0)
    pass
pass
pass
pass
pass
pass
if 'health_lost'in outcome: health_lost= outcome['health_lost']
    pass
pass
pass
pass
pass
pass
if health_lost > 0: base_value = 1.1  # Потеря здоровья - важный опыт
    pass
pass
pass
pass
pass
pass
if 'skill_used'in context: base_value = 1.1  # Использование скиллов важно
    pass
pass
pass
pass
pass
pass
if 'item_used'in context: base_value = 1.05  # Использование предметов
    pass
pass
pass
pass
pass
pass
return m in(base_value, 1.0)  # Ограничиваем максимальную ценность
def get_relevant_mem or ies(self, mem or y_type: Mem or yType, context: Dict[str
    pass
pass
pass
pass
pass
pass
Any],
limit: int= 10) -> Lis t[Mem or yEntry]:
pass  # Добавлен pass в пустой блок"""Получение релевантных записей памяти"""# Фильтруем по типу памяти
relevant= [mem for memin self.mem or y.mem or ies if mem.get('mem or y_type') = mem or y_type.value]:
pass  # Добавлен pass в пустой блок
# Сортируем по релевантности(простая эвристика)
def relevance_sc or e(mem or y: Dict[str, Any]) -> float: sc or e= mem or y.get('learning_value', 0)
    pass
pass
pass
pass
pass
pass
# Бонус за похожий контекст
context_similarity= self._calculate_context_similarity(mem or y.get('context', {}), context)
sc or e = context_similarity * 0.3
# Бонус за недавность
time_diff= time.time() - mem or y.get('timestamp', 0):
pass  # Добавлен pass в пустой блок
recency_bonus= max(0, 1.0 - time_diff / 3600.0)  # 1 час: pass  # Добавлен pass в пустой блок
sc or e = recency_bonus * 0.2
return sc or e
relevant.s or t(ke = relevance_sc or e, revers = True)
# Конвертируем обратно в Mem or yEntry
return [Mem or yEntry.from_dict(mem) for memin relevant[:limit]]
def _calculate_context_similarity(self, context1: Dict[str, Any]
    pass
pass
pass
pass
pass
pass
context2: Dict[str, Any]) -> float: pass  # Добавлен pass в пустой блок"""Вычисление схожести контекстов"""if not context1 or not context2: return 0.0
# Простая эвристика схожести
common_keys= set(context1.keys()) & set(context2.keys())
if not common_keys: return 0.0
    pass
pass
pass
pass
pass
pass
similarity= 0.0
for keyin common_keys: val1= context1[key]
    pass
pass
pass
pass
pass
pass
val2= context2[key]
if isin stance(val1, (in t, float))and isin stance(val2, (in t
    pass
pass
pass
pass
pass
pass
float)):
pass  # Добавлен pass в пустой блок
# Числовые значения
max_val= max(abs(val1), abs(val2))
if max_val > 0: similarity = 1.0 - abs(val1 - val2) / max_val
    pass
pass
pass
pass
pass
pass
elif isin stance(val1, str)and isin stance(val2, str):
    pass
pass
pass
pass
pass
pass
# Строковые значения
if val1 = val2: similarity = 1.0
    pass
pass
pass
pass
pass
pass
elif val1in val2 or val2in val1: similarity = 0.5
    pass
pass
pass
pass
pass
pass
return similarity / len(common_keys)
def end_generation(self, cause_of_death: Optional[str]= None
    pass
pass
pass
pass
pass
pass
fin al_stats: Optional[Dict[str, Any]]= None):
pass  # Добавлен pass в пустой блок"""Завершение текущего поколения"""
if not fin al_stats: fin al_stats= self.stats.copy()
    pass
pass
pass
pass
pass
pass
# Конвертируем память в Mem or yEntry
mem or ies= []
for mem_dictin self.mem or y.mem or ies: try: pass
    pass
pass
pass
pass
pass
except Exception as e: pass
pass
pass
logger.warning(f"Ошибка конвертации памяти: {e}")
# Создаем память поколения
generation_mem or y= GenerationMem or y(
generation_i = self.current_generation,
entity_i = self.entity_id,
entity_typ = self.entity_type,
start_tim = self.generation_start_time,
end_tim = time.time(),
total_experienc = self.generation_experience,
mem or ie = mem or ies,
fin al_stat = final_stats,
cause_of_deat = cause_of_death
)
# Добавляем в память поколений
self.generation_mem or ies.append(generation_mem or y)
# Ограничиваем размер памяти поколений
if len(self.generation_mem or ies) > self.generation_mem or y_capacity: pass
    pass
pass
pass
pass
pass
# Удаляем старые поколения с низким опытом
self.generation_mem or ies.s or t(ke = lambda x: x.total_experience)
self.generation_mem or ies= self.generation_mem or ies[ - self.generation_mem or y_capacity:]
# Обновляем статистику
self.stats['total_generations'] = 1
# Сбрасываем текущее поколение
self.current_generation = 1
self.generation_start_time= time.time()
self.generation_experience= 0.0
# Сохраняем память
self._save_mem or y()
logger.in fo(f"Поколение {generation_mem or y.generation_id} завершено: {cause_of_death or 'естественная смерть'}")
def get_learning_data(self) -> Dict[str, Any]:
    pass
pass
pass
pass
pass
pass
"""Получение данных для обучения ИИ"""# Анализируем память для извлечения паттернов
patterns= self._analyze_patterns()
# Получаем статистику успешных действий
successful_combat= [mem for memin self.mem or y.mem or ies: if mem.get('mem or y_type') = Mem or yType.COMBAT.valueand mem.get('success', False)]:
pass  # Добавлен pass в пустой блок
failed_combat= [mem for memin self.mem or y.mem or ies: if mem.get('mem or y_type') = Mem or yType.COMBAT.valueand not mem.get('success', True)]:
pass  # Добавлен pass в пустой блок
# Анализируем использование скиллов
skill_usage= {}
for memin self.mem or y.mem or ies: if mem.get('mem or y_type') = Mem or yType.SKILL_USAGE.value: skill_name= mem.get('context', {}).get('skill_name', 'unknown')
    pass
pass
pass
pass
pass
pass
if skill_name notin skill_usage: skill_usage[skill_name]= {'success': 0, 'total': 0}
    pass
pass
pass
pass
pass
pass
skill_usage[skill_name]['total'] = 1
if mem.get('success', False):
    pass
pass
pass
pass
pass
pass
skill_usage[skill_name]['success'] = 1
return {
'patterns': patterns,
'combat_success_rate': len(successful_combat) / max(1, len(successful_combat) + len(failed_combat)),
'skill_usage': skill_usage,
'recent_mem or ies': self.mem or y.mem or ies[ - 10:],
'generation_stats': {
'current_generation': self.current_generation,
'total_generations': self.stats['total_generations'],
'total_experience': self.stats['total_experience']
}
}
def _analyze_patterns(self) -> Dict[str, Any]:"""Анализ паттернов в памяти"""
    pass
pass
pass
pass
pass
pass
patterns= {
'preferred_actions': {},
'successful_combin ations': [],
'avoided_situations': [],
'optimal_ranges': {}
}
# Анализируем предпочитаемые действия
action_counts= {}
for memin self.mem or y.mem or ies: action= mem.get('action', '')
    pass
pass
pass
pass
pass
pass
if action notin action_counts: action_counts[action]= {'success': 0, 'total': 0}
    pass
pass
pass
pass
pass
pass
action_counts[action]['total'] = 1
if mem.get('success', False):
    pass
pass
pass
pass
pass
pass
action_counts[action]['success'] = 1
# Находим наиболее успешные действия
for action, countsin action_counts.items():
    pass
pass
pass
pass
pass
pass
success_rate= counts['success'] / counts['total']
if success_rate > 0.6:  # Успешность выше 60%
    pass
pass
pass
pass
pass
pass
patterns['preferred_actions'][action]= success_rate
# Анализируем успешные комбинации действий
recent_mem or ies= self.mem or y.mem or ies[ - 20:]  # Последние 20 действий
for iin range(len(recent_mem or ies) - 1):
    pass
pass
pass
pass
pass
pass
mem1= recent_mem or ies[i]
mem2= recent_mem or ies[i + 1]
if mem1.get('success', False)and mem2.get('success', False):
    pass
pass
pass
pass
pass
pass
combin ation= f"{mem1.get('action', '')} -> {mem2.get('action', '')}"
if combin ation notin patterns['successful_combin ations']:
    pass
pass
pass
pass
pass
pass
patterns['successful_combin ations'].append(combin ation)
return patterns
def _get_mem or y_file_path(self) -> str: pass
    pass
pass
pass
pass
pass
"""Получение пути к файлу памяти"""
mem or y_dir= f"saves / ai_mem or y/{getattr(self, 'save_slot', 'default')}":
pass  # Добавлен pass в пустой блок
os.makedirs(mem or y_dir, exis t_o = True)
return f"{mem or y_dir} / {self.entity_id}_mem or y.json"def _save_mem or y(self):"""Сохранение памяти в файл"""
try: except Exception as e: pass
pass
pass
logger.err or(f"Ошибка сохранения памяти: {e}")
def _load_mem or y(self):
    pass
pass
pass
pass
pass
pass
"""Загрузка памяти из файла"""
try: file_path= self._get_mem or y_file_path()
if not os.path.exis ts(file_path):
    pass
pass
pass
pass
pass
pass
logger.debug(f"Файл памяти не найден: {file_path}")
return
with open(file_path, 'r', encodin = 'utf - 8') as f: mem or y_data= json.load(f)
    pass
pass
pass
pass
pass
pass
# Загружаем статистику
self.stats= mem or y_data.get('stats', self.stats)
self.current_generation= mem or y_data.get('current_generation', 0)
# Загружаем память поколений
generation_data= mem or y_data.get('generation_mem or ies', [])
self.generation_mem or ies= [GenerationMem or y.from_dict(gen) for geningeneration_data]:
pass  # Добавлен pass в пустой блок
logger.in fo(f"Память загружена: {self.entity_id} ({len(self.generation_mem or ies)} поколений)")
except Exception as e: pass
pass
pass
logger.err or(f"Ошибка загрузки памяти: {e}")
def get_mem or y_summary(self) -> Dict[str, Any]:
    pass
pass
pass
pass
pass
pass
"""Получение сводки памяти"""
return {
'entity_id': self.entity_id,
'entity_type': self.entity_type.value,
'current_generation': self.current_generation,
'total_generations': self.stats['total_generations'],
'total_experience': self.stats['total_experience'],
'current_mem or ies': len(self.mem or y.mem or ies),
'generation_mem or ies': len(self.generation_mem or ies),
'learning_rate': self.learning_rate,
'success_rate': self.stats['successful_actions'] / max(1, self.stats['successful_actions'] + self.stats['failed_actions'])
}
